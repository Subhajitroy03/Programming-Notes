INTRODUCTION TO KOTLIN

1) CREATING A HELLO WORLD PROGRAM
fun main(){
	printf("Hello world")
}

2)CREATING VARIABLE
A) if you want to change the variable later
var <variablename>: <variable type> = <value>
var name: String = "Subhajit"

**kotlin is statically typed lang,i.e, it checks the datatype of variableat the compile time not at the run time
B) if you dont want to change the variable (const)
 
val <variablename>: <variable type> = <value>

HOW TO PRINT VARIABLE

printf("Hello $name")
use dollar sign to indicate variable

TYPE INFERENCE

we donot need to mention the data type it takes it auto
eg:
var name = "Subhajit" 
//name is now a string and it cannot be changed like name=5 will not work

TO GET INTEGER MAX VALUE AND MIN VALUE
val max=Int.MAX_VALUE
val min=Int.MIN_VALUE

			DATA TYPES IN KOTLIN
			
1. Basic Data Types in Kotlin
(a) Numbers

Kotlin has number types similar to Java but more concise:

Byte ‚Üí 8-bit (‚àí128 to 127)

Short ‚Üí 16-bit (‚àí32,768 to 32,767)

Int ‚Üí 32-bit (‚àí2¬≥¬π to 2¬≥¬π‚àí1)

Long ‚Üí 64-bit (‚àí2‚Å∂¬≥ to 2‚Å∂¬≥‚àí1)

Float ‚Üí 32-bit floating point (decimal numbers)

Double ‚Üí 64-bit floating point (high precision decimals)

Example:

val a: Int = 100
val b: Long = 10000000000L
val c: Float = 10.5f
val d: Double = 20.99

(b) Characters (Char)

Represents a single character (Unicode).

Written in single quotes 'A', '1'.

val grade: Char = 'A'

(c) Booleans (Boolean)

Only two values: true or false.

val isKotlinEasy: Boolean = true

(d) Strings (String)

A sequence of characters.

Written in double quotes.

Supports string interpolation with $.

val name: String = "Kotlin"
val greeting = "Hello, $name"


Multi-line string:

val text = """
    This is
    a multi-line
    string.
"""


üîπ Types of Operators in Kotlin
1. Arithmetic Operators

Used for basic math.

Operator	Meaning	Example
+	Addition	a + b
-	Subtraction	a - b
*	Multiplication	a * b
/	Division	a / b
%	Modulus	a % b

üëâ Example:

val a = 10
val b = 3
println(a + b)  // 13
println(a % b)  // 1

2. Assignment Operators

Used to assign values.

Operator	Example	Equivalent to
=	a = b	assigns value
+=	a += b	a = a + b
-=	a -= b	a = a - b
*=	a *= b	a = a * b
/=	a /= b	a = a / b
%=	a %= b	a = a % b
3. Unary Operators

Operate on a single operand.

Operator	Meaning	Example
+	Unary plus	+a
-	Unary minus	-a
++	Increment	a++ or ++a
--	Decrement	a-- or --a
!	Logical NOT	!true ‚Üí false

üëâ Example:

var x = 5
println(++x) // 6
println(--x) // 5

4. Comparison Operators

Used to compare values (returns Boolean).

Operator	Meaning	Example
==	Equal to	a == b
!=	Not equal to	a != b
<	Less than	a < b
>	Greater than	a > b
<=	Less or equal	a <= b
>=	Greater or equal	a >= b
5. Logical Operators

Used with Booleans.

Operator	Meaning	Example
&&	Logical AND	(a > b && b > 0)
`		`
!	Logical NOT	!(a > b)
6. Bitwise Operators

In Kotlin, no direct symbols like &, |, ^, ~. Instead, they are functions:

Function	Meaning	Example
shl(bits)	Shift left	a.shl(2)
shr(bits)	Shift right	a.shr(2)
ushr(bits)	Unsigned shift right	a.ushr(2)
and(bits)	Bitwise AND	a.and(b)
or(bits)	Bitwise OR	a.or(b)
xor(bits)	Bitwise XOR	a.xor(b)
inv()	Bitwise NOT	a.inv()
7. Range Operators

Used to create ranges.

Operator	Meaning	Example
..	Range	1..5 ‚Üí 1,2,3,4,5
downTo	Reverse range	5 downTo 1
step	Step value	1..10 step 2
8. Index Access Operator

Used to access array or list elements.

Internally calls get(index) or set(index, value).

val arr = arrayOf(10, 20, 30)
println(arr[1])  // 20


IF ELSE IN KOTLIN
if (){
}
else if(){
}
else{
}

like C++/JAVA

WHEN keyword 
In Kotlin, when is like a switch-case in other languages (C, Java, etc.), but more powerful.

example 1 - 

fun main() {
    val x = 2

    when (x) {
        1 -> println("x is 1")
        2 -> println("x is 2")
        3 -> println("x is 3")
        else -> println("x is something else")
    }
}

example 2 -

Using Ranges in when
fun main() {
    val marks = 85

    when (marks) {
        in 90..100 -> println("Excellent")
        in 75..89 -> println("Good")
        in 50..74 -> println("Average")
        else -> println("Fail")
    }
}

example - 3

Using when as Expression (returns value)
fun main() {
    val a = 10
    val b = 20
    val max = when {
        a > b -> a
        else -> b
    }
    println("Maximum is $max")
}


Safe Call Operator ?.

Avoids NullPointerException.

A string can have null value sometimes ..so if we dont use ? operator the app will get NullPointerException and will crash
so we use ? sign to indicate that it can have null value
val text: String? = null
println(text?.length) // null instead of error
similarly we are calling length function and using safe operator
if string is not null it returns the length else it returns null
( we can also use if else block to check and print)

Elvis Operator ?:

Used to provide a default value if the variable is null.

val name: String? = null
val result = name ?: "default text"
println(result) // default text
BUT if, 
val name: String? = "hello"
val result = name ?: "default text"
println(result) // "hello"

FUNCTIONS IN KOTLIN

fun main() {
    sayHello(name: "Alex", age: 22)   ///calling fucntion with arguments
}

fun sayHello(name: String, age: Int) {   //taking two parameters and their data type
    println("Hello, $name! Your age is $age")
}
		
**we cannot change value of parameters inside the function

Functions with return values

fun main(args: Array<String>) {
    val max = getMax(a: 5, b: 9)
    println(max)
}

fun getMax(a: Int, b: Int): Int {   /// the return data type must be mentioned like that
    val max = if (a > b) a else b
    return max
}


if the function is single lined
shortcut: 
fun getMax(a: Int, b: Int)= if (a > b) a else b

Function overloading works same as in java

DEFAULT PARAMETERS IN KOTLIN	

fun sendMessage(name: String = "User", message: String = "") {
    println("Name = $name and message = $message")
}

ONE MORE EXAMPLE: 
fun main(args: Array<String>) {
    sendMessage(
        name = "Alexa"
    )
}

fun sendMessage(name: String = "User", message: String = sendText()) {
    println("Name = $name and message = $message")
}

fun sendText(): String {
    return "Some text!"
}

WHEN FUNCTION CALL , WE CAN ALSO SPECIFY THE PARAMETER NAME WITH VALUE

VARARGS (VARIABLE ARGUMENT)

fun main(args: Array<String>) {
    println(sum(5, 6, 7, 10, 5, 6, 4, 5, 3, 4, 5, 6, 4, 4, 6, 5))
}

fun sum(vararg numbers: Int): Int {  //HERE numbers is an array of Int
    var result = 0
    for (number in numbers) {
        result += number
    }
    return result
}
short explanation:
vararg in Kotlin lets you pass any number of arguments to a function (like arrays but more flexible).
Here, sum(vararg numbers: Int) accepts multiple integers.
A for loop adds all numbers into result.
Finally, result is returned.

LOOPS IN KOTLIN
1. For Loop

Used to iterate over ranges, arrays, collections.

(a) Range loop

for (i in 1..5) {
    println(i)   // prints 1 to 5   ( ".." IS A RANGE OF OPERATOR)
}

(b) With `downTo` and `step`   

for (i in 10 downTo 1 step 2) {
    println(i)   // 10, 8, 6, 4, 2
}

c) until
.. includes the end value.
until excludes the end value (like half-open range).

for (i in 1 until 5) {
    println(i)   // prints 1, 2, 3, 4 (does NOT include 5)
}
 
With step
for (i in 0 until 10 step 2) {
    println(i)   // prints 0, 2, 4, 6, 8
}

While Loop

Executes as long as condition is true.

var i = 1
while (i <= 5) {
    println(i)
    i++
}

Do-While Loop
Executes at least once, then checks condition.

var j = 1
do {
    println(j)
    j++
} while (j <= 5)

Loop Control Statements

break ‚Üí exits the loop immediately.

continue ‚Üí skips current iteration and moves to the next.

return ‚Üí exits the whole function.

for (i in 1..5) {
    if (i == 3) continue  // skips 3
    if (i == 4) break     // stops loop
    println(i)
}

Normal Nested Loop
for (i in 1..3) {
    for (j in 1..3) {
        println("i = $i, j = $j")
    }
}


Using break (stops only inner loop)
for (i in 1..3) {
    for (j in 1..3) {
        if (j == 2) break
        println("i = $i, j = $j")
    }
}

output-
i = 1, j = 1
i = 2, j = 1
i = 3, j = 1


Using Labeled Break (break@outer)

Sometimes you want to stop outer loop from inside an inner loop.
You can do this with labels.
outer@ for (i in 1..3) {
    for (j in 1..3) {
        if (j == 2) break@outer   // stops outer loop
        println("i = $i, j = $j")
    }
}
Output:
i = 1, j = 1

(Execution stops completely when j == 2)

ARRAYS IN KOTLIN

fun main() {
	//Declaring array (of string )
	
    val names: Array<String> = arrayOf("John","Stephen","Megan")
	// or simply
	val names= arrayOf("John","Stephen","Megan")
	
	//array of multiple data types (like python)
    val numbers= arrayOf(4,5,6,7,4,"Name 1",'a')
	(in reality: val numbers: Array<Comparable<*> & java.io.Serializable> = arrayOf(4,5,6,7,4,"Name 1",'a'))
	
    names[0] = "Alex"
    println("First element: ${names[0]}")  // zero based indexing
    println("The size of the array is: ${names.size}") //length of array

    for (name : String in names) {   //enhanced for loop for array just like java
        println(name)
    }
}

val numbers= arrayOf(4,5,6,7,4,"Name 1",'a')
for( i in numbers){
	if(i is Int){
		println(i)   //prints only integers from mixed array
	}
}

				OOPS IN KOTLIN	

//class defination
class Student {
    var name: String = ""
    var age: Int = 0

    fun display() {
        println("Name: $name, Age: $age")
    }
}
//creating object
fun main() {
    val s1 = Student()   // object of Student
    s1.name = "Rahul"
    s1.age = 20
    s1.display()
}

o/p - Name: Rahul, Age: 20

Constructor in Kotlin

Constructors help initialize objects.
Option 1) This is good when if we want to manipulate the input by user
eg- we could do var brand: String = brand.trim() to remove whitespace(leading and trailing)
so we are taking the input and then manipulating it and then we are assigning it to the property of the class 

class Car(brand: String,year: Int) {
	var brand: String = brand
	var year: Int = year
    fun show() {
        println("Car: $brand, Year: $year")
    }
}
Option 2) Simple version: directly in parameter

class Car(var brand: String, var year: Int) {
    fun show() {
        println("Car: $brand, Year: $year")
    }
}

fun main() {
    val c1 = Car("Tesla", 2024)
    c1.show()
}

Output:
Car: Tesla, Year: 2024 

Initializer Block (init):
If we want to run some code every time an object is created, we use init.

class Car(val brand: String, val year: Int) {
    init {
        println("Car object is created: $brand ($year)")
    }
}
fun main() {
    val c1 = Car("Tesla", 2024)
}

Output:
Car object is created: Tesla (2024)

**There could be more than one init block and they will be executed sequentially

Secondary Constructor

Sometimes we need multiple ways to create an object. That‚Äôs where secondary constructors help.
(Constructor overloading)
class Person {
    var name: String
    var age: Int

    // Primary constructor not used here
    constructor(name: String, age: Int) {
        this.name = name
        this.age = age
    }

    constructor(name: String) {   // secondary constructor
        this.name = name
        this.age = 18             // default value
    }

    fun show() {
        println("Name: $name, Age: $age")
    }
}

fun main() {
    val p1 = Person("Rohit", 22)
    val p2 = Person("Sneha")   // age defaults to 18

    p1.show()
    p2.show()
}

Output:
Name: Rohit, Age: 22
Name: Sneha, Age: 18

***PRIMARY + SECONDARY CONSTRUCTOR

class Book(val title: String, val price: Int, val author: String) {

    // Secondary constructor 1 ‚Üí only title  (this is used to call the primary constructor and assign value to each properties)
    constructor(title: String) : this(title, 100, "Unknown"){
		//we can also add some code if this constructor is used 
		println("default values are used for price and author")
	}
	
    // Secondary constructor 2 ‚Üí title + price
    constructor(title: String, price: Int) : this(title, price, "Unknown"){
		println("default value is used for author")
	}
}
ANOTHER WAY OF SETTING DEFAULT VALUES


GETTER AND SETTER
class User(firstName: String, var lastName: String = "LastName", var age: Int = 0) {
    var firstName = firstName
        get() {
            return "FirstName: $field"
        }
        set(value) {
            println("$value was assigned to firstName property")
            field = value
        }
}

Kotlin by default calls getter and setter but still if we want to customise any field we can call it by this way
when we will get the field firstName (  println(S1.firstName)  ) instead of getting the first name only we will recieve another text that is "First Name " and then the value of the firstName
if we want such customised getter and setter we have to define for each field

now why we write "field" instead of name of the field "firstName"
the reason is if we write 
get(){
    return "FirstName: $firstName"
}
this will again call the getter and which will result in infinite loop (recursion)

lateinit keyword
This helps us to declare any variable which we want to initialize later
not during declaration neither by constructor
eg - 

fun main(args: Array<String>) {
    val user = User(firstName: "Alex", lastName: "Dobbin", age: 23)
    user.favoriteMovie = "Interstellar"
}
class User(var firstName: String, var lastName: String, var age: Int) {
    lateinit var favoriteMovie: String
}
Remember ... you cannot use lateinit with primitive types like Int, Double, Boolean, etc. in Kotlin.

***Companion object***

Kotlin doesn‚Äôt have static members like Java.

Instead, it provides companion objects to define members that belong to the class itself, not to instances of the class.

Functions and properties inside a companion object can be called without creating an object of the class

fun main(args: Array<String>) {
    val result: Int = Calculator.sum(a: 5, b: 10)
    val max: Int = Int.MAX_VALUE  //also a companion class of INT
    println(result)
}

class Calculator() {
    companion object {
        fun sum(a: Int, b: Int): Int {
            return a + b
        }
    }
}

LAZY KEYWORD

fun main(args: Array<String>) {
    val user1 = User(firstName: "Alex", lastName: "Dobbin", age: 23)
    val user2: User by lazy {
        User(firstName: "User1", lastName: "lastName", age: 0)
    }

    println(user2.firstName)
}


class User(var firstName: String, var lastName: String, var age: Int) {
    init {
        println("User: $firstName was created")
    }
}

if we use lazy keyword , the obj is not initialized until and unless we use it
if we dont write "println(user2.firstName)" user2 is not initialized and thus we will get no print statement


ENUM IN KOTLIN
(SAME AS JAVA)
BASIC EXAMPLE -
enum class Direction() {
    NORTH,
    SOUTH,
    EAST,
    WEST
}
fun main() {
    println(Direction.NORTH)
    println(Direction.EAST)
}

ENUM WITH CONSTRUCTOR
 
enum class Direction(var direction: String, var distance: Int) {
    NORTH(direction = "north", distance = 10),
    SOUTH(direction = "south", distance = 20),
    EAST(direction = "east", distance = 15),
    WEST(direction = "west", distance = 40)
}

O/P -
north
10
NORTH

INNER CLASS IN KOTLIN (SAME AS JAVA)
fun main(args: Array<String>) {
    val listView = ListView(arrayOf("Name 1", "Name 2", "Name 3", "Name 4"))

    listView.ListViewItem().displayItem(position = 2)
}

class ListView(val items: Array<String>) {

    inner class ListViewItem {

        fun displayItem(position: Int) {
            println(items[position])
        }
    }
}

INHERITANCE IN KOTLIN

fun main(args: Array<String>) {
    val car = Car(name= "BMW", color= "RED", engines= 1, doors= 4)
    val plane = Plane(name= "Boeing", color= "WHITE and BLUE", engines= 4, doors= 4)

    car.move()
    car.stop()

    plane.move()
    plane.stop()
}
 /// THE OPEN KEYWORD IS USED BECAUSE BY DEFAULT CLASSES ARE FINAL (CANNOT BE INHERITED)
open class Vehicle(val name: String, val color: String) {
    fun move() {
        println("$name is moving")
    }

    fun stop() {
        println("$name has stopped")
    }
}
 //DONT USE VAR FOR NAME AND COLOR AS THEY WILL BE INITIALISED BY PARENT CONSTRUCTOR
class Car(name: String, color: String, val engines: Int, val doors: Int) : Vehicle(name, color) {
}


//SYNTAX TO INHERIT
class Plane(name: String, color: String, val engines: Int, val doors: Int) : Vehicle(name, color) {
}


FUNCTION OVERRIDING

fun main(args: Array<String>) {
    val car = Car(name= "BMW", color= "RED", engines= 1, doors= 4)
    val plane = Plane(name= "Boeing", color= "WHITE and BLUE", engines= 4, doors= 4)

    car.move()
    car.stop()

    plane.move()
    plane.stop()
}

open class Vehicle(val name: String, val color: String) {
    open fun move() {   // mark as open so it can be overridden
        println("$name is moving")
    }

    open fun stop() {   // mark as open so it can be overridden
        println("$name has stopped")
    }
}

class Car(name: String, color: String, val engines: Int, val doors: Int) : Vehicle(name, color) {
    override fun move() { //USE THE OVERRIDE KEYWORD
        println("Car $name with $engines engine(s) and $doors doors is driving on the road")
    }

    override fun stop() { //USE THE OVERRIDE KEYWORD
        println("Car $name has stopped at the signal")
    }
}

class Plane(name: String, color: String, val engines: Int, val doors: Int) : Vehicle(name, color) {
    override fun move() {   //USE THE OVERRIDE KEYWORD
        println("Plane $name with $engines engine(s) is flying in the sky")
    }

    override fun stop() {
        println("Plane $name has landed safely")
    }
}


SEALED CLASS IN Java

FINAL KEYWORD TOTALLY RESTRICTS THE INHERITANCE AND ABSTRACT CLASS MAKES EVERYONE MANDATORY TO INHERIT IT
SEALED CLASS GIVES PERMISSION TO CERTAIN CLASS TO INHERIT

sealed class A permits B, C {  //GIVING PERMISSION TO INHERIT TO B AND C BUT NOT D 
}

final class B extends A {    //THE SUBCLASS HAS TO BE EITHER "FINAL" OR "SEALED" OR "NON-SEALED"
}

final class C extends A {
}

class D {
}

public class Demo {
    public static void main(String args[]) {
        
    }
}
FINAL -> THE SUBCLASS CANNOT BE FURTHER INHERITED
SEALED -> THE SUBCLASS ALSO GIVES PERMISSION TO INHERIT TO CERTAIN OTHER CLASSES
NON-SEALED --> THE SUBCLASS GIVES PERMISSION TO INHERIT TO ALL CLASES

EG -

sealed class A permits B, C {
}

non-sealed class B extends A {  //B IS NON SEALED THAT IS ANYONE CAN INHERIT IT NOW
}

final class C extends A {
}

class D extends B {   //D EXTENDS B
}

IT CAN ALSO BE DONE TO INTERFACES
sealed interface X permits Y {
}
sealed interface Y extends X {
}
NOTE:
INTERFACES CANNOT BE FINAL SO THEY CAN EITHER BE SEALED OR NON-SEALED

SEALED CLASS IN KOTLIN

A sealed class in Kotlin is a special kind of class that restricts class inheritance.
It can only be subclassed within the same file where it is declared.
This makes it perfect for representing a fixed set of types (like enums but more powerful because subclasses can hold data).
Useful for type-safe hierarchies where you want to cover all possible cases in a when statement.

EG --
fun main() {
    val success = Result.Success("SUCCESS!")
    val progress = Result.Progress("PROGRESS")

    getData(progress)
}

fun getData(result: Result) {
    when (result) {
        is Result.Progress -> result.showMessage()
        is Result.Success -> result.showMessage()
        is Result.Error.NonRecoverableError -> result.showMessage()
        is Result.Error.RecoverableError -> result.showMessage()
    }
}

sealed class Result(val message: String) {
    fun showMessage() {
        println("Result: $message")
    }

    class Success(message: String) : Result(message)

    sealed class Error(message: String) : Result(message) {
        class RecoverableError(exception: Exception, message: String) : Error(message)
        class NonRecoverableError(exception: Exception, message: String) : Error(message)
    }

    class Progress(message: String) : Result(message)
}



STRUCTURAL EQUALITY VS REFERENTIAL EQUALITY
" == " IS STRUCTURAL EQUALITY BECAUSE IT CHECKS IF THE CONTENT OF TWO VAR IS SAME OR NOT
" === " IS REFERENTIAL EQUALITY BECAUSE IT CHECKS IF THE REFERENCE OF BOTH VARIABLE IS SAME OR NOT

eg = 
name1="Ram"
name2="Ram"
name1==name2  ----> True
name1===name2 -----> False


HOW TO MAKE TWO OBJECTS EQUAL??

ANY OBJECT BY DEFAULT INHERITS THE CLASS "ANY" AND IT HAS A METHOD WHICH WE HAVE TO OVERRIDE THE "equal" METHOD

fun main(args: Array<String>) {
    val user1 = User(firstName = "Alex", lastName = "Dobbin", age = 23)
    val user2 = User(firstName = "Alex", lastName = "Dobbin", age = 23)

    println(user1 == user2)
}

class User(var firstName: String, var lastName: String, var age: Int) {
    override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true
        }   // if they are equal by reference then they will also be equal by content
        if (other is User) {
            return this.firstName == other.firstName
                    && this.lastName == other.lastName
                    && this.age == other.age
        }  //compares the other parameters only if the other object is same as this
        return false
    }
}

toString() function and hashcode function

override fun hashCode(): Int {
    return 0
}

override fun toString(): String {
    return "User(firstName='${firstName}', lastName='${lastName}', age=${age})"
}


This Kotlin code provides an explanation of the hashCode() and toString() methods, which are commonly overridden for data classes and other objects.

Code
Kotlin

override fun hashCode(): Int {
    return 0
}

override fun toString(): String {
    return "User(firstName='${firstName}', lastName='${lastName}', age=${age})"
}
Explanation of hashCode()
The hashCode() method is used to get a unique integer value for an object. 
It's crucial for objects used in hash-based collections like HashMap and HashSet.
The contract of equals() and hashCode() dictates that if two objects are considered 
equal (i.e., equals() returns true), they must have the same hash code.

In the provided code, the hashCode() method is simply returning 0. 
While this is a valid implementation, it is a poor practice because it violates the principle of a good hash function: to distribute hash codes evenly. Returning a constant value means every User object will have the same hash code.

Explanation of toString()
The toString() method provides a string representation of an object. 
The default implementation typically returns a string like com.example.User@7b1a4030, which is not very useful for debugging or logging.

The provided toString() method is an override that returns a meaningful string.


WHAT IS DATA CLASS?

A data class in Kotlin is a special type of class designed to hold data. 
The compiler automatically generates useful methods for you, saving you from writing a lot of boilerplate code.

What It Does for You
When you declare a class as a data class, 
the Kotlin compiler automatically provides the following methods based 
on the properties defined in its primary constructor:

equals(): Compares two objects based on the values of their properties. If all properties are the same, the objects are considered equal.

hashCode(): Generates a hash code from the property values. This is essential for using the objects in hash-based collections like HashMap or HashSet.

toString(): Creates a readable string representation of the object, showing the name and value of each property (e.g., User(name=John, age=30)).

componentN(): Allows you to destructure the object, assigning its properties to separate variables. For example, val (name, age) = user.

copy(): Creates a new instance of the data class with the same property values as the original, allowing you to easily modify specific properties without changing the original object.

example- 
 //declaring the data class
data class User(val name: String, val age: Int)

fun main() {
    val user1 = User("Alice", 25)
    val user2 = User("Alice", 25)

    // Automatically generated methods in action
    println(user1.equals(user2))   // true, because the data is the same
    println(user1)      // User(name=Alice, age=25)
}

NOTE- 
Data Classes Cannot Be abstract, open, sealed, or inner
Data Classes Must Have a Primary Constructor

INTERFACE IN KOTLIN

interface Engine {
    fun startEngine()
}

class Car(val name: String, val color: String): Engine {
    override fun startEngine() {
        println("The car is starting the engine.")
    }
}

class Truck(val name: String, val color: String): Engine {
    override fun startEngine() {
        println("The truck is starting the engine.")
    }
}

class Plane(val name: String, val color: String): Engine {
    override fun startEngine() {
        println("The plane is starting the engine.")
    }
}

Interface vs Abstract Class (wrt to java)

// Interface = contract (no state)
interface Flyable {
    fun fly()        // abstract by default
}

// Abstract class = base class (can have state + common code)
abstract class Animal(val name: String) {
    abstract fun sound()   // abstract method
    fun sleep() {          // concrete method
        println("$name is sleeping.")
    }
}

USE OF Delegate IN KOTLIN
(Long version)

interface A{
    fun sample1()
    fun sample2()
    fun sample3()
}
class B():A{
    override fun sample1(){
        println("Sample 1 ")
    }
    override fun sample2(){
        println("Sample 2 ")
    }
    override fun sample3(){
        println("Sample 3 ")
    }
}
class C(val a:A):A{
    override fun sample1() {
        a.sample1()
    }

    override fun sample2() {
        a.sample2()
    }

    override fun sample3() {
        a.sample3()
    }
}
fun main(){
    val x=B()
    val y=C(x)
    y.sample1()
    y.sample2()
    y.sample3()
}

(Using Delegate : short version)
interface A{
    fun sample1()
    fun sample2()
    fun sample3()
}
class B():A{
    override fun sample1(){
        println("Sample 1 ")
    }
    override fun sample2(){
        println("Sample 2 ")
    }
    override fun sample3(){
        println("Sample 3 ")
    }
}
class C(val a:A):A by a{
}
fun main(){
    val x=B()
    val y=C(x)
    y.sample1()
    y.sample2()
    y.sample3()
}

COLLECTION IN KOTLIN

Types of Collections
In Kotlin, collections are categorized into two forms. 

Immutable Collection
Mutable Collection

1. Immutable Collection
It means that it supports only read-only functionalities and can not be modified by its elements. Immutable Collections and their corresponding methods are:  

List - listOf() and listOf<T>()
Set - setOf()
Map - mapOf()

// An example for immutable list
fun main() {
    val immutableList = listOf("Ram","Raj","Sita")
    for(item in immutableList){
        println(item)
    }
}

Set

It is a collection of unordered elements, also it does not support duplicate elements

fun main(args: Array<String>) {
    // initialize with duplicate values 
      // but output with no repetition
    var immutableSet = setOf(6,9,9,0,0,"Mahipal","Nikhil")
    for(item in immutableSet){
        println(item)
    }     
}
Output6
9
0
Ram
Sita

Map
Map keys are unique and hold only one value for each key, it is a set of key-value pairs

fun main() {
    var immutableMap = mapOf(9 to "Ram",8 to "Raj",7 to "Sita")
    for(key in immutableMap.keys){
        println(immutableMap[key])
    }
}
2. Mutable Collection 
It supports both read and write functionalities. Mutable collections and their corresponding methods are:  

List - mutableListOf(),arrayListOf() and ArrayList
Set - mutableSetOf(), hashSetOf()
Map - mutableMapOf(), hashMapOf() and HashMap
List

fun main(args : Array<String>) {
    var mutableList = mutableListOf("Raj","Ram","Sita")
    // we can modify the element
    mutableList[0] = "Laxman"
    // add one more element in the list
    mutableList.add("Ravan")
    for(item in mutableList){
        println(item)
    }
}

Set
fun main(args: Array<String>) {
    var mutableSet = mutableSetOf<Int>(6,10)
    // adding elements in set
    mutableSet.add(2)
    mutableSet.add(5)
    for(item in mutableSet){
        println(item)
    }
}

NOTE:   if we use user defined object in set , set cannot find unique as it doesnot know the logic to 
make equal, be default all objects are unique irrespective of their content
so either override the equals logic or use demo class

Map
fun main(args : Array<String>) {
    var mutableMap = mutableMapOf<Int,String>(1 to "Raj",2 to "Ram",3 to "Sita")
    // we can modify the element
    mutableMap.put(1,"Laxman")
    // add one more element in the list
    mutableMap.put(4,"Ravan")
    for(item in mutableMap.values){
        println(item)
    }
}

FLATTEN FUNCTION
// LIST OF SET
val numbersSets: List<Set<Int>> = listOf(setOf(1,2,3), setOf(4,5,6), setOf(7,8,9))
for (numbers: Set<Int> in numbersSets) {
    for (number: Int in numbers) {
        println(number)
    }
    println("\n")
}
 //FLATTEN
val numbersFlatten: List<Int> = numbersSets.flatten()  //2D ARRAY TO 1D ARRAY
for (number: Int in numbersFlatten) {
    println(number)
}


STRING MANIPULATION

fun main() {
    val numbersStrings: List<String> = listOf("one", "two", "three", "four")
    println(numbersStrings) // Prints the list directly ‚Üí [one, two, three, four]
    println(numbersStrings.joinToString())  
	//joinToString() converts the list into a single string with elements separated by , (default).
	Output: one, two, three, four.

    val listString = StringBuffer().also { it.append("The list of numbers: ") } //Creates a StringBuffer and initializes it with the text "The list of numbers: ".
    println(numbersStrings.joinToString(separator = " | ", prefix = "start: ", postfix = ": end"))
	
	//Joins list elements with | as a separator.
	Adds "start: " before and ": end" after the joined string.
	Output: start: one | two | three | four: end.
	
	
    val numbers: List<Int> = (1 .. 100).toList()  //Creates a list of integers from 1 to 100.
    println(numbers.joinToString(limit = 25, truncated = "<...>"))
	//Joins numbers into a string, but limits to 25 elements.After that, it shows <...> instead of the remaining numbers.
    
	println(numbersStrings.joinToString { "Element: ${it.uppercase()}" })
	//Custom transformation applied to each element
	Each string is converted to uppercase and formatted as "Element: VALUE".
	Output: Element: ONE, Element: TWO, Element: THREE, Element: FOUR.
}

FILTER AND PARTISION

fun main() {
    val numbers: List<String> = listOf("one","two","three","four")
    val longerThan3 = numbers.filter { it.length > 3 }  //Filters elements whose length is greater than 3 ‚Üí result: ["three", "four"].
    println(longerThan3)

    val numbersMap: Map<String, Int> = mapOf("key 1" to 1, "key 2" to 2, "key 3" to 3, "key 101" to 101)
    val filteredMap: Map<String, Int> = numbersMap.filter { it.key.endsWith("1") && it.value > 100 }
    println(filteredMap) 
	//Filters only entries where: Key ends with "1". AND Value > 100.
	Result: {"key 101"=101}.

    val filteredIdx: List<String> = numbers.filterIndexed { index: Int, value: String -> (index != 0) && (value.length < 5)}
    val filteredNot = numbers.filterNot { it.length <= 3 }
    println(filteredIdx)
    println(filteredNot)
	
	//filterIndexed: keeps only elements where:
	Index ‚â† 0.
	Length < 5.
	‚Üí Result: ["two", "four"].

	filterNot: opposite of filter. Removes elements with length ‚â§ 3.
	‚Üí Result: ["three", "four"].
	
    val mixedList: List<Comparable<*>> = listOf(1,2,3,'A','B','C',"Hello World","Alex",false)
    mixedList.filterIsInstance<Boolean>().forEach { println(it) }
	// mixedList contains numbers, characters, strings, and a boolean.
	// filterIsInstance<Boolean>() picks only booleans.

    // Partition
    println("\n")

    val (match: List<String>, rest: List<String>) = numbers.partition { it.length > 3 }
    println(match)
    println(rest)
	
}
ADDING AND DELETING Element

fun main() {
    val numbers: MutableList<String> = mutableListOf("one", "two", "three", "four")
    val plusList: List<String> = numbers + "five"
    val minusList: List<String> = numbers - mutableListOf("three", "four")
    println(plusList)
    println(minusList)
}


The + operator in Kotlin creates a new list with the additional element.
The - operator in Kotlin removes elements from a list and returns a new list.

GROUP BY 
fun main() {
    val numbers: List<String> = listOf("one", "two", "three", "four", "five")

    println(numbers.groupBy { it.first().uppercase() })
    println(numbers.groupBy(keySelector = { it.first() }, valueTransform = { it.uppercase() }))
}

List Operations

fun main() {
    val numbers: List<String> = listOf("one", "two", "three", "four", "five", "six")
    println(numbers.slice(1..3))  // Takes elements from index 1 to 3.
    println(numbers.slice(0..4 step 2)) //Takes elements from indices 0 to 4, stepping by 2.
    println(numbers.slice(setOf(3, 5, 0))) //Picks elements at indices 3, 5, and 0.
	// Result: ["four", "six", "one"]
	
    println("\n")
    println(numbers.take(3))  // Takes the first 3 elements.
    println(numbers.takeLast(3)) // Takes the last 3 elements.
    println(numbers.drop(1))  //Drops the first element, returns the rest.
    println(numbers.dropLast(5)) //Drops the last 5 elements, keeping only the first.

    println("\n")
    println(numbers.takeWhile { !it.startsWith("f") }) 
	//Takes elements while condition is true.
	//Stops when an element starts with "f".
	//Result: ["one", "two", "three"]
	
    println(numbers.takeLastWhile { it != "three" })
	//Starts from the end and takes elements until it finds "three".
	
    println(numbers.dropWhile { it.length == 3 })
	//Drops elements from start while their length == 3. "one" and "two" have length 3, so they are dropped.
    
	println(numbers.dropLastWhile { it.contains("i") })
	//Drops elements from end while they contain "i". "six" and "five" contain "i", so they are removed.
	
}

val numbers: List<Int> = (0 .. 13).toList()
//Creates a list of integers from 0 to 13 (inclusive).
//(0..13) is an IntRange; .toList() converts it to a List<Int>:

println(numbers.chunked(size = 3))  
#The chunked function splits the list into sublists (‚Äúchunks‚Äù) of the specified size (3 here).
#Example output:[[0,1,2], [3,4,5], [6,7,8], [9,10,11], [12,13]]
println(numbers.chunked(size = 3) { it.sum() })
// This is an overloaded version of chunked.
Instead of returning the chunks themselves, it applies a transform function to each chunk ‚Äî in this case it.sum() (sums the elements of each chunk).
Example output: [3, 12, 21, 30, 25]  // sums of each chunk above


fun main() {
    val numbers: List<String> = listOf("one", "two", "three", "four", "five")

    println(numbers.elementAt(index = 3))  //Gets the element at index 3
    println(numbers.first())    // Returns the first element in the list.
    println(numbers.last())  // Returns the last element in the list.

    println(numbers.first { it.length > 3 })  //Finds the first element matching the predicate it.length > 3 (length > 3):
    println(numbers.last { it.startsWith(prefix = "f") }) //Finds the last element matching the predicate it.startsWith("f"):

    println(numbers.random()) //Returns a random element from the list.
    println(numbers.isEmpty())  //Checks whether the list is empty.
}

fun main() {
    val numbers: List<Int> = listOf(6, 10, 14, 4, 100)

    println("The sum is ${numbers.sum()}") //Sums all the numbers in the list.
    println("The count is: ${numbers.count()}") //Counts the number of elements in the list.
    println("The average is: ${numbers.average()}") //Calculates the average (mean) of all elements.
    println("The max value is: ${numbers.maxOrNull()}") //Returns the maximum element or null if the list is empty.
    println("The min value is: ${numbers.minOrNull()}") //Returns the minimum element or null if the list is empty.
    println("The sum is: ${numbers.sumOf { it * 2 }}") //Sums the result of applying the given lambda to each element.Here: it * 2 doubles each number first, then sums.
}


Kotlin Comparator vs Comparable

Implement Comparable Interface
To implement the Comparable interface, you need to override the compareTo method in your class.

data class Person(val firstname: String, val lastname: String, val age: Int) : Comparable<Person> {
    override fun compareTo(other: Person): Int {
        return when {
            this.age < other.age -> -1
            this.age > other.age -> 1
            else -> 0
        }
    }
}

fun main() {
    val person1 = Person("John", "Doe", 30)
    val person2 = Person("Jane", "Doe", 25)

    println("Person1: $person1")
    println("Person2: $person2")

    println("Comparison result: ${person1.compareTo(person2)}")
}

// Output:

// Person1: Person(firstname=John, lastname=Doe, age=30)
// Person2: Person(firstname=Jane, lastname=Doe, age=25)
// Comparison result: 1


Sorting with Comparable
When you use Kotlin‚Äôs standard library functions to sort a list of Person objects, it will use the natural ordering provided by the compareTo method:

val people = listOf(Person("John", "Doe", 30), Person("Jane", "Doe", 25))
val sortedPeople = people.sorted()
The sorted method will sort the list based on the natural ordering defined by compareTo.

Introducing Comparator

Creating a Comparator
You can create a Comparator by implementing the compare method. Here‚Äôs how you can create a Comparator for the Person class to sort by lastname in descending order

data class Person(val firstname: String, val lastname: String)

// Create the comparator for Person objects based on last name
val lastNameComparator = Comparator<Person> { p1, p2 ->
    p2.lastname.compareTo(p1.lastname)
}

fun main() {
    val people = listOf(
        Person("John", "Doe"),
        Person("Jane", "Smith"),
        Person("Emily", "Johnson")
    )

    // Sort the list using the lastNameComparator
    val sortedPeople = people.sortedWith(lastNameComparator)

    for (person in sortedPeople) {
        println("${person.firstname} ${person.lastname}")
    }
}

// Output:

// Jane Smith
// Emily Johnson
// John Doe

Multiple Criteria
Comparator is especially useful when you need to sort objects based on multiple criteria. For example, you might want to sort Person objects by lastname and then by age:

data class Person(val firstName: String, val lastName: String, val age: Int)

// Create a Comparator to compare Person objects by lastName and then by age
val multiCriteriaComparator = Comparator<Person> { p1, p2 ->
    when {
        p1.lastName != p2.lastName -> p1.lastName.compareTo(p2.lastName)
        else -> p1.age.compareTo(p2.age)
    }
}

fun main() {
    val people = listOf(
        Person("John", "Doe", 30),
        Person("Jane", "Doe", 25),
        Person("Alice", "Smith", 28),
        Person("Bob", "Brown", 32),
        Person("Charlie", "Doe", 22) // Added for demonstration
    )

    // Sort the list using the multiCriteriaComparator
    val sortedByMultipleCriteria = people.sortedWith(multiCriteriaComparator)

    sortedByMultipleCriteria.forEach { println(it) }
}

// Output:

// Person(firstName=Bob, lastName=Brown, age=32)
// Person(firstName=Charlie, lastName=Doe, age=22)
// Person(firstName=Jane, lastName=Doe, age=25)
// Person(firstName=John, lastName=Doe, age=30)
// Person(firstName=Alice, lastName=Smith, age=28)


Visibility modifiers
There are four visibility modifiers in Kotlin: private, protected, internal, and public. The default visibility is public.

Functions, properties, classes, objects, and interfaces can be declared at the "top-level" directly inside a package:

// file name: example.kt
package foo

fun baz() { ... }
class Bar { ... }

If you don't use a visibility modifier, public is used by default, which means that your declarations will be visible everywhere.

If you mark a declaration as private, it will only be visible inside the file that contains the declaration.

If you mark it as internal, it will be visible everywhere in the same module.

The protected modifier is not available for top-level declarations.

Class membersÔªø

For members declared inside a class:

private means that the member is visible inside this class only (including all its members).

protected means that the member has the same visibility as one marked as private, but that it is also visible in subclasses.

internal means that any client inside this module who sees the declaring class sees its internal members.

public means that any client who sees the declaring class sees its public members.

If you override a protected or an internal member and do not specify the visibility explicitly, the overriding member will also have the same visibility as the original.


EXCEPTION HANDLING IN KOTLIN

Try Catch Block

You can also assign values to variables in try catch

fun main(args: Array<String>) {
    val a = 5
    val b = 0

    val result: Int = try {
        println(a / b)
        a / b
    } catch (e: ArithmeticException) {
        println("You can't divide by zero: ${e.message}")
        0
    } finally {
        println("Divide by zero.")
    }

    println(result)
}

Lamda Function

fun main(args: Array<String>) {

	// LAMDA FUNCTION
    val myLambda = { a: Int, b: Int -> println("a + b = ${a + b}") }
	
	//TYPE OF THIS LAMDA FUNCTION: (Int,Int)->Unit (as it takes two integers and returns nothing)

    myLambda(8, 9)
}
 //NORMAL FUNCTION
fun add(a: Int, b: Int) {
    println("a + b = ${a + b}")
}


fun main(args: Array<String>) {

    val loginButton = Button(text = "Login", id = 34345) {
        // login user  (a lambda function, currently just a comment)
    }

    val singUpButton = Button(text = "Sing Up", id = 2345) {
        // sing up the user (a lambda function, currently just a comment) 
    }
}

class Button(val text: String, val id: Int, val onClickListener: () -> Unit)
 /// onClickListener: () -> Unit ‚Üí a lambda function that runs when the button is clicked.
 
 
SINGLE PARAMETER LAMDA FUNCTION

fun main(args: Array<String>) {
    upperCase(str = "hello") { s:String -> s.uppercase() }
}

fun upperCase(str: String, myFunction: (String) -> String) {
    val uppercasedWord = myFunction(str)
    println(uppercasedWord)
}


Now this can be replaced with: 
fun main(args: Array<String>) {
    upperCase(str = "hello") { it.uppercase() } //// USE "it" FOR SINGLE PARAMETER LAMDA FUNCTION
}

fun upperCase(str: String, myFunction: (String) -> String) {
    val uppercasedWord = myFunction(str)
    println(uppercasedWord)
}

SCOPE FUNCTIONS

fun main() {
    val user = User().apply {
        firstName = "Alex"
        lastName = "Dobinca"
        age = 23
    }

    with(user) {
        println(firstName)
        println(lastName)
        println(age)
    }
}

class User {
    var firstName = ""
    var lastName = ""
    var age = -1
}


NOTE- 
APPLY SCOPE FUNCTIONS
apply { ... } is a scope function.
It is called on an object (User()) and lets you configure/initialize it.
Inside apply, this refers to the object (here User).
The object itself is returned from apply.
So after this block, user contains a fully initialized User object.

WITH SCOPE FUNCTION
with(object) { ... } is another scope function.
It takes an object (user) as argument and makes it available inside the block as this.
Usually used to perform multiple operations on the same object without repeating its name.
Here, it prints all the user details.

THE LAST VALUE OF "WITH" FUNCTION IS THE RETURN VALUE OF THE FUNCTION (last expression inside its block)

EG- 
val result=with(user) {
        println(firstName)
        println(lastName)
        println(age)
		0
    }
so result is 0

also scope function

User("Subhajit","Roy",23).also{
	print(it)
}
data class User(var firstName:String,var lastName:String,var age:Int)


also is a scope function used when you want to do some side effects (logging, printing, debugging, etc.) 
without changing the object itself.
Inside also, the object is referenced by it (not this).
also returns the original object after executing the block.

run scope function

fun main() {
    val user: User? = null

    val result = user?.run {
        println(firstName)
        println(lastName)
        println(age)
        23
    }
}

data class User(val firstName: String, val lastName: String, val age: Int)

run is a scope function that:
Executes the block with this as the object (user in this case).
Returns the last expression in the block.
Here, the last expression is 23, so result = 23.
Notice the safe call (?.):
If user is null, the block won‚Äôt run at all and result will be null.
If user is not null, it will print the values and return 23.

Use run when you want both null-safety and a return value.
Use with when the object is non-null and you want to group multiple operations.


let scope function

fun main() {

    var text: String? = null  ///text is declared as a nullable String (it can hold either a String or null).

    val result = text?.let {   //text?.let { ... } runs the block only if text is not null.
        println(it)
        "text"
    }
}

data class User(val firstName: String, val lastName: String, val age: Int)


THREADS IN KOTLIN

fun main(args: Array<String>) {
    println("Hello World! 1")
    println("Hello World! 2")
    println("Hello World! 3")
    println("Hello World! 4")
    println("Hello World! 5")

    thread {
        Thread.sleep(5000)
        println("Thread 2 has finished")
    }

    println("Hello World! 6")
    println("Hello World! 7")
    println("Hello World! 8")
    println("Hello World! 9")
    println("Hello World! 10")
    println("Hello World! 11")
}


This launches a new background thread using Kotlin‚Äôs thread { } function.

Inside the new thread:

It sleeps for 5 seconds (Thread.sleep(5000)).

After waking up, it prints "Thread 2 has finished".

This doesn‚Äôt block the main thread ‚Äî the main thread keeps executing immediately after starting this thread.

WHY WE NEED TO USE COROUTINES

In Kotlin, threads work fine for small tasks ‚Äî but they are heavy (expensive to create, limited in number, slow to switch between).
That‚Äôs why coroutines exist: they‚Äôre a lightweight concurrency mechanism built into Kotlin.

Lightweight vs Threads
Creating a thread = a full OS thread (MBs of memory, scheduling overhead).
Creating a coroutine = just a small object in the JVM (KBs of memory).
You can run thousands of coroutines in a single thread without choking the system ‚Äî but you can‚Äôt do that with raw threads.

Structured Concurrency

Threads don‚Äôt have a built-in ‚Äúscope‚Äù ‚Äî you must manage lifecycle and cancellation yourself.
Coroutines use CoroutineScope + Job so you can cancel them all at once when your activity, view model, or app stops.
This prevents leaks and runaway background tasks.


COROUTINES IN KOTLIN

Consider the following code: 

NOTE: after the main function is executed the thread is still executed 


fun main() {                     // Executes in main thread

    println("Main program starts: ${Thread.currentThread().name}")

    thread {                     // creates a background thread (worker thread)
        println("Fake work starts: ${Thread.currentThread().name}")
        Thread.sleep(1000)       // Pretend doing some work... may be file upload
        println("Fake work finished: ${Thread.currentThread().name}")
    }

    println("Main program ends: ${Thread.currentThread().name}")
}

output- 
Main program starts: main
Fake work starts: Thread-0
Main program ends: main
Fake work finished: Thread-0

Now , let us use coroutines instead of threads

import kotlinx.coroutines.*

fun main() {        // Executes in main thread

    println("Main program starts: ${Thread.currentThread().name}")

    GlobalScope.launch {    // creates a background coroutine that runs on a background thread
        println("Fake work starts: ${Thread.currentThread().name}")
        Thread.sleep(1000)      // Pretend doing some work... may be file upload
        println("Fake work finished: ${Thread.currentThread().name}")
    }

    // Blocks the current main thread & wait for coroutine to finish (practically not a right way to wait)
    Thread.sleep(2000)
    println("Main program ends: ${Thread.currentThread().name}")
}

Here the main function is not waiting for the coroutines to complete the tasks so we are using sleep to do it manually
But this solution is not practical since we dont know how much time the real operations will take

so instead of sleep we will use delay function 
Thread.sleep()  --> Pauses the current thread for a specified time.The entire thread is blocked.No other code on that thread executes during the sleep.
delay() --> Suspends a coroutine without blocking the underlying thread.Only suspends the coroutine; the thread is free to run other coroutines or tasks.

import kotlinx.coroutines.*
fun main() = runBlocking {        // Executes in main thread

        println("Main program starts: ${Thread.currentThread().name}")  // main thread

        GlobalScope.launch {    // Thread: T1
            println("Fake work starts: ${Thread.currentThread().name}")     // Thread: T1
            delay(1000)   // Coroutine is suspended but Thread: T1 is free (not blocked)
            println("Fake work finished: ${Thread.currentThread().name}") // Either T1 or some other thread.
        }

        delay(2000)  // main thread: wait for coroutine to finish (practically not a right way to wait)

        println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

Now delay() is a suspending function which cannot be used outside coroutine ... 
so we create another coroutine "runBlocking" which blocks the thread in which it is operated ..
the given code is an optimized function , but we can also use runblocking around delay(2000) only


You can also use and create your own suspending function using suspend keyword (output still same)

import kotlinx.coroutines.*

fun main() = runBlocking {        // Executes in main thread
        println("Main program starts: ${Thread.currentThread().name}")  // main thread
        GlobalScope.launch {    // Thread: T1
            println("Fake work starts: ${Thread.currentThread().name}")     // Thread: T1
            mySuspendFunc(1000)   // Coroutine is suspended but Thread: T1 is free (not blocked)
            println("Fake work finished: ${Thread.currentThread().name}") // Either T1 or some other thread.
        }
        mySuspendFunc(2000)  // main thread: wait for coroutine to finish (practically not a right way to wait)
        println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

suspend fun mySuspendFunc(time: Long) {
    // code..
    delay(time)
}

launch vs GlobalScope.launch

if we only write launch then it is made locally .. suppose you are on login screen and you launch a 
coroutine C1.. then you go to home screen and launch another coroutine C2
now if you quit the home screen the C2 coroutine will get destroyed , so we need to use GlobalScope so that the 

GlobalScope.launch  -> File download / music playing (discouraged use only when you need)
launch  -> data computation , login operation  (by default)

launch coroutine

import kotlinx.coroutines.*


fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val job: Job = launch {   // Thread: main (if not global it inherits the parent thread)
        println("Fake work starts: ${Thread.currentThread().name}")     // Thread: main
        delay(1000)   // Coroutine is suspended but Thread: main is free (not blocked)
        println("Fake work finished: ${Thread.currentThread().name}") // Thread: main
    }
	//instead of delay we should use it
    job.join()      // main thread: wait for coroutine to finish 

    println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

Note- 
Returns a job obj to control the coroutine
launches a coroutine without blocking the thread
inhertits the thread and coroutine scope from the immediate parent coroutine

A Kotlin coroutine launched with the launch builder is called "fire and forget" 
because it starts a new coroutine to run a task in the background and 
doesn't return a result to the caller

async function

import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val deferredJob: Deferred<Int> = async   // Thread: main
        println("Fake work starts: ${Thread.currentThread().name}")     // Thread: main
        delay(1000)   // Coroutine is suspended but Thread: main is free (not blocked)
        println("Fake work finished: ${Thread.currentThread().name}") // Thread: main
        15   //returned obj
    }

    val num: Int = deferredJob.await()  // main thread: wait for coroutine to finish and return data 

    println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

if nothing is returned then: 

 val deferredJob: Deferred<Unit> = async   // Thread: main
        println("Fake work starts: ${Thread.currentThread().name}")     // Thread: main
        delay(1000)   // Coroutine is suspended but Thread: main is free (not blocked)
        println("Fake work finished: ${Thread.currentThread().name}") // Thread: main
    }
	deferredJob.join()

NOTES:
inhertits the thread and coroutine scope from the immediate parent coroutine
Returns a Deferred<T> object  (generic)
you can cancel the coroutine, wait for it or retrieve the returned result 

Deferred<T> is a sub class of Job

CANCELING COROUTINES

To cancel a coroutine, it should be cooperative.

val job = launch {
    // ..the code has to be cooperative in order to get cancelled..
}

job.cancel()  // If the coroutine is cooperative then cancel it
job.join()    // Waits for the coroutine to finish

// If the coroutine is cooperative then cancel it else, if it is not cooperative
// then wait for the coroutine to finish
job.cancelAndJoin()

Two Ways to Make Coroutine Cooperative

Periodically invoke a suspending function that checks for cancellation.
Only those suspending functions that belongs to kotlinx.coroutines package will make coroutine cooperative
delay(), yield(), withContext(), withTimeout() etc. are the suspending functions that belongs to kotlinx.coroutines package

eg- 
import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val job: Job = launch {     // Thread main: Creates a non-blocking coroutine
        for (i in 0..500) {
            print("$i.")
            yield()     // or use delay() or any other suspending function as per your need.
        }
    }

    delay(10)  // Let's print a few values before we cancel
    job.cancelAndJoin()

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}

This will print some of the output and then cancel the execution as it is taking much more time

isActive() function:
if the code is not co-operative (using Thread.sleep) then it converts it to cooperative
if the coroutine is Active : isActive = True
if the coroutine is not active : isActive = False

import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val job: Job = launch(Dispatchers.Default) {     // Thread T1: Creates a non-blocking coroutine
        for (i in 0..500) {
            if (!isActive) {
                return@launch // or use break statement
            }
            print("$i.")
            Thread.sleep(1)
        }
    }

    delay(10)  // Let's print a few values before we cancel
    job.cancelAndJoin()

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}

EXCEPTION HANDLING IN COROUTINES
import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val job: Job = launch(Dispatchers.Default) {     // Thread T1: Creates a non-blocking coroutine
        try {
            for (i in 0..500) {
                print("$i.")
                delay(5)    // or use yield() or any other suspending function as per your need.
            }
        } catch (ex: CancellationException) {
            print("\nException caught safely: ${ex.message}")
        } finally {
            print("\nClose resources in finally")
        }
    }

    delay(10)  // Let's print a few values before we cancel
    job.cancel(CancellationException("My own crash message"))
    job.join()

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}

try-catch-finally: This block is used to handle cancellation:
When a coroutine is cancelled, it throws a CancellationException.
The catch block intercepts this exception, allowing for safe cleanup or logging.
The finally block is always executed after cancellation, guaranteeing that resources can be safely closed, regardless of whether the loop finished or was cancelled.

withContext(NonCancellable) -->	Ensures the code inside will not be interrupted by the parent coroutine's cancellation.

import kotlinx.coroutines.*
fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)
    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val job: Job = launch(Dispatchers.Default) {     // Thread T1: Creates a non-blocking coroutine
        try {
            for (i in 0..500) {
                print("$i.")
                delay(5)    // or use yield() or any other suspending function as per your need.
            }
        } catch (ex: CancellationException) {
            print("\nException caught safely: ${ex.message}")
        } finally {
            withContext(NonCancellable) {
                delay(1000)     // Generally we don't use suspending function in finally
                print("\nClose resources in finally")
            }
        }
    }

    delay(10)  // Let's print a few values before we cancel
    job.cancel(CancellationException("My own crash message"))
    job.join()

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}

If we need to use a suspending function inside a finally block and must guarantee that it won't be cancelled by the surrounding coroutine's cancellation signal,
we wrap it in withContext(NonCancellable)

withTimeout Function

The use of withTimeout is to automatically cancel a block of suspending code if it takes too long to execute.

import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    withTimeout(1300) {   //withTimeout(1300): This is the core function. It runs the code block inside it, but sets a maximum time limit of 1300 milliseconds (1.3 seconds).
        try {
            for (i in 0..1000) {
                print("$i.")
                delay(500)
            }
        } catch (ex: TimeoutCancellationException) {
            // .. code..
        } finally {
            // .. code..
        }
    }

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}


withTimeoutOrNull function

Unlike withTimeout, which throws a TimeoutCancellationException on timeout, 
withTimeoutOrNull handles the cancellation internally and returns null.

import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val result: String? = withTimeoutOrNull(2000) {
        for (i in 0..500) {
            print("$i.")
            delay(500)
        }

        "I am done"
    }

    print("Result: $result")

    println("\nMain program ends: ${Thread.currentThread().name}")    // main thread
}

If the coroutine completed the loop without interruption (i.e., before 2000 ms elapsed), it would return the string "I am done"
If the coroutine times out (i.e., does not complete the loop before 2000¬†ms elapsed), the withTimeoutOrNull function will return null.

BY DEFAULT , SUSPENDING FUNCTIONS ARE EXECUTED SEQUENCIALLY

import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val time = measureTimeMillis {
        val msgOne = getMessageOne()  // took 1000 ms
        val msgTwo = getMessageTwo()  // took 1000 ms
        println("The entire message is: ${msgOne + msgTwo}")
    }

    println("Completed in $time ms")   // 1000+1000=2000 ms
    println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

suspend fun getMessageOne(): String {
    delay(1000L)    // pretend to do some work
    return "Hello "
}

suspend fun getMessageTwo(): String {
    delay(1000L)    // pretend to do some work
    return "World!"
}

CONCURRENT EXECUTION

Achieve parallel execution 

import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis


fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val time = measureTimeMillis {
        val msgOne: Deferred<String> = async {
            // ..more code..
            getMessageOne()
        }
        val msgTwo: Deferred<String> = async {
            // ..more code..
            getMessageTwo()
        }
        println("The entire message is: ${msgOne.await() + msgTwo.await()}")
    }

    println("Completed in $time ms")
    println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

suspend fun getMessageOne(): String {
    delay(1000L)    // pretend to do some work
    return "Hello "
}

suspend fun getMessageTwo(): String {
    delay(1000L)    // pretend to do some work
    return "World!"
}

NOTE- 
The entire message is: Hello World!
Completed in 1142 ms (parallel execution)

LAZY COROUTINE EXECUTION
Lazily execute code in coroutine


import kotlinx.coroutines.*

fun main() = runBlocking {    // Creates a blocking coroutine that executes in current thread (main)

    println("Main program starts: ${Thread.currentThread().name}")  // main thread

    val msgOne: Deferred<String> = async(start = CoroutineStart.LAZY) { getMessageOne() }
    val msgTwo: Deferred<String> = async(start = CoroutineStart.LAZY) { getMessageTwo() }
    println("The entire message is: ${msgOne.await() + msgTwo.await()}")

    println("Main program ends: ${Thread.currentThread().name}")    // main thread
}

suspend fun getMessageOne(): String {
    delay(1000L)    // pretend to do some work
    println("After working in getMessageOne()")
    return "Hello "
}

suspend fun getMessageTwo(): String {
    delay(1000L)    // pretend to do some work
    println("After working in getMessageTwo()")
    return "World!"
}


Functions are executed only if the returned values are used in program
if the println statement is commented, then the functions will not be executed

COROUTINE SCOPE
import kotlinx.coroutines.*

fun main() = runBlocking {

    println("runBlocking: $this")

    launch {
        println("launch: $this")

        launch(coroutineContext) {
            println("child launch: $this")
        }
    }

    async {
        println("async: $this")
    }

    println("... some other code...")
}

** this HAS THE COROUTINE SCOPE


COROUTINE CONTEXT

import kotlinx.coroutines.*

fun main() = runBlocking {

    // this: CoroutineScope instance
    // coroutineContext: CoroutineContext instance

    /* Without Parameter: CONFINED      [CONFINED DISPATCHER]
        - Inherits CoroutineContext from immediate parent coroutine.
        - Even after delay() or suspending function, it continues to run in the same thread.  */
    launch {
        println("C1: ${Thread.currentThread().name}")       // Thread: main
        delay(1000)
        println("C1 after delay: ${Thread.currentThread().name}")   // Thread: main
    }

    /* With parameter: Dispatchers.Default [similar to GlobalScope.launch { } ]
        - Gets its own context at Global level. Executes in a separate background thread.
        - After delay() or suspending function execution,
            it continues to run either in the same thread or some other thread.  */
    launch(Dispatchers.Default) {
        println("C2: ${Thread.currentThread().name}")   // Thread: T1
        delay(1000)
        println("C2 after delay: ${Thread.currentThread().name}")   // Thread: Either T1 or some other thread
    }

    /*  With parameter: Dispatchers.Unconfined      [UNCONFINED DISPATCHER]
        - Inherits CoroutineContext from the immediate parent coroutine.
        - After delay() or suspending function execution, it continues to run in some other thread.  */
    launch(Dispatchers.Unconfined) {
        println("C3: ${Thread.currentThread().name}")   // Thread: main
        delay(1000)
        println("C3 after delay: ${Thread.currentThread().name}")   // Thread: some other thread T1
    }

    launch(coroutineContext) {
        println("C4: ${Thread.currentThread().name}")       // Thread: main
        delay(1000)
        println("C4 after delay: ${Thread.currentThread().name}")   // Thread: main 
    }

    println("...Main Program...")
}

Generics in Kotlin

Generics let you write flexible, reusable code that works with different data types while keeping your program type-safe (checking for errors before it runs).

1. Basic Generics
Placeholder Type: We use angle brackets (<>) to define a placeholder type, usually <T> (for "Type") or <E> (for "Element").

Generic Class: You declare the placeholder on the class name.

Example: class Box<T>(val item: T)

Generic Function: The placeholder is declared before the function name and return type.

Example: fun <T> display(data: T)

Usage: When you create the class, you specify the actual type.

Example: val intBox = Box<Int>(10) or Kotlin often infers the type: val strBox = Box("Hello").

2. Constraints (Limiting Types)
You can restrict what type T can be using the colon (:) notation. This is called setting an Upper Bound.

Example: fun <T : Number> process(value: T)

This means T can only be Number or any of its subtypes (like Int, Float, or Double). It prevents you from passing a String.

3. Variance (Controlling Subtyping)
Variance keywords control how a container (List<String>, Box<Int>) relates to its supertypes/subtypes.

out (Covariant - Producer):

Use this when the type T is only produced (returned) by the class.

Rule of thumb: You can only read (get) the value.

in (Contravariant - Consumer):

Use this when the type T is only consumed (passed as an argument) by the class.

Rule of thumb: You can only write (put) the value.

Default (Invariant): If you use neither in nor out, the types must match exactly.

4. Type Projection (Use-Site Variance)
This lets you temporarily set the variance requirement for a generic type when you are using it in a function.

List<out T>: Means "For this specific function call, I will only read items from this list."

List<in T>: Means "For this specific function call, I will only write items of type T or its supertypes into this list."

List<*> (Star Projection): Means "I don't know the type, but I can safely read its contents as Any?."