										FAST API NOTES


----------------------------------------------
BASIC
-----------------------------------------------
Pydantic is a data validation library used within FastAPI to check if the data coming into your API is correct and in the right format. It helps overcome Python's default lack of type checking, which is crucial for building robust APIs.

Starlette is the component within FastAPI that manages how your API receives HTTP requests from clients and sends back responses. It handles the communication aspect of the API.

Single Gateway Interface
An SGI is one gateway endpoint that:
	Receives all client requests
	Routes them to the correct internal service/API
	Applies cross-cutting concerns in one place
	
WSGI
Web Server Gateway Interface
Synchronous
Old but rock-solid
Used by Flask, Django (classic)
Client → Web Server → WSGI App → Response

Used when:
Simple APIs
Blocking I/O is acceptable


ASGI
Asynchronous Server Gateway Interface

Async-first
Handles HTTP, WebSockets, background tasks
Used by FastAPI, Starlette, Django (async)
Client → ASGI Server → Async App → Response

Used when:
High concurrency
WebSockets
Async DB / external calls

WSGI and ASGI are Python-only interface standards.
They define how a Python web server talks to a Python web application.


Node.js already has this built in.
Node HTTP Server ↔ Express App
Express is literally a function wrapped around Node’s HTTP server.
No extra interface standard was ever needed.

--------------------------------------------------------------------------
PRACTICAL
-----------------------------------------------------------------------------
1) TO CREATE AN VIRTUAL ENVIRONMENT FOR PACKAGES TO BE INSTALLED LOCALLY

python -m venv myenv(name of environment)

now to activate it , copy the path of script/activate and run it ( myenv\Scripts\activate )

now if you do pip install ... it will be only for that project 

if you want to deactivate , simply deactivate

2) pip install fastapi uvicorn pydantic
(uvicorn for web server in python)

 (starlette is inbuilt in fastapi)
to run the file , we should write "uvicorn main:app --reload" (filename-> main.py, app is the fastapi obj, --relooad = refresh when saved like nodemon)

3)SAMPLE SERVER
main.py

from fastapi import FastAPI
app=FastAPI()

@app.get("/")
def greet():
	return {"message":"Hello World"}


4) pydantic is used for data validation
model.py

from pydantic import BaseModel

class Product(BaseModel):
	id:int
	name:str
	desc:str
	price:float
	quantity:int
	
now in main.py, we can import it and make a list of product like

products=[
	Product(id=1,name="Book",desc="good book",price=45.26,quantity=5),
	Product(id=2,name="Pen",desc="good pen",price=5.2,quantity=50)
]

5) In fastapi, swagger is inbuilt avaiable
simply: localhost:8000/docs

(can still use postman or insomania)


6) How to use params

app.get("/product/{id}")
def get_product_by_id(id:int): ## var name should be same
	..............
	.logics and code..
	.................
7) POST REQ

@app.post("/product")
def add_product(product: Product):
	products.append(product)
	return product

now this product will come from any react based app or by req body in swagger or postman

NOTE:
PUT replaces an entire resource with the data sent (idempotent), while PATCH applies partial modifications to a resource (not inherently idempotent); PUT requires sending the full resource, risking data loss for missing fields, whereas PATCH sends only changes, making it more efficient for smaller updates


**PATH FUNCTION -> for more readibility of path parameters

from fastapi import Path
app.get("/product/{id}")
def get_product_by_id(id:int,Path(...,description="id of user",example="01",)):
	..........................
	.....................
	.............
	
** RAISING ERROR

from fastapi import HTTPException

and whereever needed, use

raise HTTPException(status_code=404,detail="User not found")

** USING QUERY PARAMETERS

@app.get('/sort')
def sort_patients(sort_by: str=Query(..., description="Sort on the basis of Height, Weight or BMI."),order: str = Query("ascending", description="Sort in ascending or descending order.")):

    valid_fields = ["Height", "Weight", "BMI"]
    
    if sort_by not in valid_fields:
        raise HTTPException(
            status_code=400, 
            detail=f"Invalid field. Select from {valid_fields}"
        )
    
    if order not in ["ascending", "descending"]:
        raise HTTPException(
            status_code=400, 
            detail="Invalid order. Select between ascending and descending."
        )

    .................
	...code..........
	................
	
** MORE ABOUT PYDANTIC MODEL ***

Best Example of Pydantic Model

from pydantic import BaseModel, EmailStr, AnyUrl, Field
from typing import List, Dict, Optional

class Patient(BaseModel):

    name: str = Field(max_length=50)  // Field is to set constraints, here name must be max 50 char
    email: EmailStr                    // custom data type from pydantic , here for valid email
    linkedin_url: AnyUrl               // custom data type from pydantic , here for valid URL
    age: int = Field(gt=0, lt=120)     // age must be between 0 and 120
    weight: float = Field(gt=0)        // weight must be greater than 0
    married: bool = False              // seting default values 
    allergies: Optional[List[str]] = None  // Optional is used to make it optional and default is None
    contact_details: Dict[str, str]  //using Dict and List to check datatype of its element or key or value

**USING ANNOTATED**

This is used to add metadata

class Patient(BaseModel):

    name: Annotated[str, Field(
        max_length=50,
        title='Name of the patient',
        description='Give the name of the patient in less than 50 chars',
        examples=['Nitish', 'Amit']
    )]
    email: EmailStr
    linkedin_url: AnyUrl
    age: int = Field(gt=0, lt=120)
    weight: Annotated[float, Field(gt=0, strict=True)]  //Strict:True means it will not change datatype
    married: Annotated[bool, Field(default=None, description='Is the patient married or not')]
    allergies: Annotated[Optional[List[str]], Field(default=None, max_length=5)]
    contact_details: Dict[str, str]

**USING FIELD VALIDATORS**

USED TO APPLY CUSTOM LOGIC ON DATA

from pydantic import BaseModel, Field, field_validator
from typing import List, Dict

class Patient(BaseModel):
    name: str
    age: int
    weight: float
    married: bool
    allergies: List[str] = Field(default_factory=list)
    contact_details: Dict[str, str]

    @field_validator("name")   	      /// write the name of field here
    @classmethod                     /// must write it
    def validate_name(cls, value: str):   // function to apply checks
        if len(value.strip()) < 2:
            raise ValueError("Name must have at least 2 characters")
        if any(char.isdigit() for char in value):
            raise ValueError("Name must not contain numbers")
        return value.strip()

    @field_validator("age")
    @classmethod
    def validate_age(cls, value: int):
        if value < 0 or value > 120:
            raise ValueError("Age must be between 0 and 120")
        return value

** MODEL VALIDATORS **

Used when we need multiple fields to check a single field

eg- if age>60 , there should be an emergency contact in contact dictionary

class Patient(BaseModel):
    name: str
    email: EmailStr
    age: int
    weight: float
    married: bool
    allergies: List[str]
    contact_details: Dict[str, str]

    @model_validator(mode='after')
    def validate_emergency_contact(cls, model):
        if model.age > 60 and 'emergency' not in model.contact_details:
            raise ValueError('Patients older than 60 must have an emergency contact')
        return model
    

--------------------------------------------------------
FOR DATABASE CONNECTION
--------------------------------------------------------

SQLAlchemy is an open-source Python SQL toolkit and Object-Relational Mapper (ORM) library that simplifies interaction with relational databases

pip install sqlalchemy
pip install mysql-connector-python   (driver)

--------------------------------------------------
database.py
--------------------------------------------------
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base

db_url="full link"
engine=create_engine(db_url)
session=sessionmaker(autocommit=False,autoflush=False,bind=engine)
Base = declarative_base()

------------------------------------------------------
database_model.py
-------------------------------------------------------

from sqlalchemy import Column, Integer, String, Float
from database import Base

examples: 

class Books(Base):
    __tablename__ = "books"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String)
    author = Column(String)
    description = Column(String)
    rating = Column(Integer)

class Product(Base):
    __tablename__ = "product"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String)
    description = Column(String)
    price = Column(Float)
    quantity = Column(Integer)

Now in main.py/app.py

from fastapi import FastAPI, HTTPException
import models
from database import engine, SessionLocal
from sqlalchemy.orm import Session

app = FastAPI()

models.Base.metadata.create_all(bind=engine)

def get_db():
    try:
        db = SessionLocal()
        yield db
    finally:
        db.close()


@app.get("/")
def read_api(db: Session = Depends(get_db)):  ## imp: has to pass this db obj everywhere everytime
    return db.query(models.Books).all()


@app.post("/")
def create_book(book: Book, db: Session = Depends(get_db)): ### make a pydantic model first

    book_model = models.Books()    // declaring the model book and mapping it with pydantic model
    book_model.title = book.title
    book_model.author = book.author
    book_model.description = book.description
    book_model.rating = book.rating

    db.add(book_model)   //adding to database
    db.commit()          // as autocommit is off

    return book

**UPDATE FULL RECORD
@app.put("/{book_id}")
def update_book(book_id: int, book: Book, db: Session = Depends(get_db)):

    book_model = db.query(models.Books).filter(models.Books.id == book_id).first()

    if book_model is None:
        raise HTTPException(
            status_code=404,
            detail=f"ID {book_id} : Does not exist"
        )

    book_model.title = book.title
    book_model.author = book.author
    book_model.description = book.description
    book_model.rating = book.rating

    db.add(book_model)
    db.commit()


**UPDATE ANY PARTICULAR RECORD

Need to make another pydantic model for it
eg-
from typing import Optional
from pydantic import BaseModel

class BookUpdate(BaseModel):
    title: Optional[str] = None
    author: Optional[str] = None
    description: Optional[str] = None
    rating: Optional[int] = None

Now in main.py use that:

@app.patch("/{book_id}")
def update_book_partial(book_id: int,book: BookUpdate,db: Session = Depends(get_db)):

    book_model = db.query(models.Books).filter(models.Books.id == book_id).first()

    if book_model is None:
        raise HTTPException(status_code=404, detail="Book not found")

    update_data = book.model_dump(exclude_unset=True)

    for key, value in update_data.items():
        setattr(book_model, key, value)

    db.commit()
    db.refresh(book_model)

    return book_model


** What this does (important):

exclude_unset=True → ignores fields not sent by client
setattr() → dynamically updates only those fields

**TO DELETE RECORDS

@app.delete("/{book_id}")
def delete_book(book_id: int, db: Session = Depends(get_db)):

    book_model = db.query(models.Books).filter(models.Books.id == book_id).first()

    if book_model is None:
        raise HTTPException(
            status_code=404,
            detail=f"ID {book_id} : Does not exist"
        )

    db.query(models.Books).filter(models.Books.id == book_id).delete()
    db.commit()
